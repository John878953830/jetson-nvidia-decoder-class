//
// Created by daisy on 2021/8/13.
//

#ifndef DECODE_TX2_DECODER_H264_H
#define DECODE_TX2_DECODER_H264_H
#include "video_decode.h"

#include <cmath>
#include <ctime>
#include <istream>
#include <getopt.h>
#include <iostream>
#include <stdio.h>
#include <sys/time.h>
#include <opencv2/calib3d/calib3d.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/xfeatures2d.hpp>
#include <vector>
#include <algorithm>
#include <cmath>
#include <opencv2/xfeatures2d/nonfree.hpp>
#include <pthread.h>
#include <unistd.h>
#include <cstring>
#include <iostream>
#include <opencv2/core/utility.hpp>
#include <opencv2/videoio.hpp>
#include <vector>
#include <mutex>
#include "NvApplicationProfiler.h"
#include "NvUtils.h"
#include <errno.h>
#include <fstream>
#include <iostream>
#include <linux/videodev2.h>
#include <malloc.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <nvbuf_utils.h>
#include <queue>
using namespace std;
//void * dec_capture_loop_fcn(void *arg);
#define TEST_ERROR(cond, str, label) \
    if (cond)                        \
    {                                \
        cerr << str << endl;         \
        error = 1;                   \
        goto label;                  \
    }

#define MICROSECOND_UNIT 1000000
#define CHUNK_SIZE 4000000

#define IS_NAL_UNIT_START(buffer_ptr) (!buffer_ptr[0] && !buffer_ptr[1] && \
                                       !buffer_ptr[2] && (buffer_ptr[3] == 1))

#define IS_NAL_UNIT_START1(buffer_ptr) (!buffer_ptr[0] && !buffer_ptr[1] && \
                                        (buffer_ptr[2] == 1))

#define H264_NAL_UNIT_CODED_SLICE 1
#define H264_NAL_UNIT_CODED_SLICE_IDR 5
#define HEVC_NUT_TRAIL_N 0
#define HEVC_NUT_RASL_R 9
#define HEVC_NUT_BLA_W_LP 16
#define HEVC_NUT_CRA_NUT 21
#define IVF_FILE_HDR_SIZE 32
#define IVF_FRAME_HDR_SIZE 12
#define IS_H264_NAL_CODED_SLICE(buffer_ptr) ((buffer_ptr[0] & 0x1F) == H264_NAL_UNIT_CODED_SLICE)
#define IS_H264_NAL_CODED_SLICE_IDR(buffer_ptr) ((buffer_ptr[0] & 0x1F) == H264_NAL_UNIT_CODED_SLICE_IDR)
#define GET_H265_NAL_UNIT_TYPE(buffer_ptr) ((buffer_ptr[0] & 0x7E) >> 1)
/**
 * @brief empty I frame for 1920*1440 image
 */
static uint8_t iframe_h20_shot_photo_h264[] = {
    0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x32,
    0xac, 0x4d, 0x00, 0xf0, 0x05, 0xad, 0x08, 0x00,
    0x00, 0x1f, 0x40, 0x00, 0x07, 0x53, 0x04, 0x78,
    0xa1, 0x55, 0x00, 0x00, 0x00, 0x01, 0x68, 0xea,
    0x8f, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x65, 0xb8,
    0x10, 0x47, 0xff, 0xfd, 0x09, 0xcf, 0x02, 0x94,
    0x54, 0xf7, 0x7c, 0xd5, 0xdf, 0x06, 0x7a, 0xa7,
    0x96, 0xd5, 0x69, 0x91, 0x18, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x93, 0xc4, 0x69, 0xad, 0xe8, 0xd6,
    0x78, 0xd6, 0xb8, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x03, 0xa8, 0x00, 0x00, 0x03, 0x01,
    0xba, 0x00, 0x00, 0x03, 0x01, 0x33, 0x00, 0x00,
    0x03, 0x00, 0xfa, 0x00, 0x00, 0x03, 0x00, 0xc9,
    0x00, 0x00, 0x03, 0x00, 0xe2, 0x00, 0x00, 0x03,
    0x00, 0xfe, 0x00, 0x00, 0x03, 0x01, 0x32, 0x00,
    0x00, 0x03, 0x02, 0x1a, 0x00, 0x00, 0x04, 0x04,
    0x00, 0x00, 0x06, 0x28, 0x00, 0x00, 0x0e, 0xc0,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x13,
    0x50, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0x72,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x03, 0x00, 0x2a, 0x00, 0x01,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x10, 0x27, 0x00,
    0x00, 0x2e, 0x63, 0x00, 0x00, 0xf5, 0x1c, 0x00,
    0x00, 0xb7, 0x15, 0x00, 0x00, 0xc8, 0xbd, 0x03,
    0x00, 0x00, 0xe1, 0xf5, 0x05, 0xc0, 0xd4, 0x01,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x40,
    0x14, 0x00, 0x00, 0x30, 0x0f, 0x00, 0x00, 0xa5,
    0x70, 0xb6, 0x12, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x03, 0x00, 0xd1, 0xcc, 0x4c,
    0x3d, 0xd0, 0xcc, 0x4c, 0x3d, 0x33, 0x33, 0x73,
    0x3f, 0xd0, 0xcc, 0x4c, 0x3d, 0x33, 0x33, 0x73,
    0x3f, 0x34, 0x33, 0x73, 0x3f, 0xd1, 0xcc, 0x4c,
    0x3d, 0x34, 0x33, 0x73, 0x3f, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x06,
    0xef, 0x02, 0x7a, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x01, 0x06, 0xff, 0x02, 0xf5, 0x00, 0x12, 0xff,
    0xa5, 0x70, 0xff, 0xb6, 0x12, 0xff, 0x00, 0x00,
    0xff, 0x00, 0x00, 0x15, 0x5a, 0xca, 0xff, 0x04,
    0x00, 0x16, 0x32, 0xcb, 0xff, 0x04, 0x00, 0x18,
    0x42, 0xcb, 0xff, 0x04, 0x00, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x01, 0x06,
    0xef, 0x02, 0xfe, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x01, 0x06, 0xf0, 0x19, 0x02, 0x00, 0x38, 0x00,
    0x63, 0x01, 0x02, 0x00, 0xd1, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x5a, 0xca, 0xff, 0x04, 0x00,
    0xff, 0x00, 0x5a, 0xff, 0x1a, 0x80, 0x00, 0x00,
    0x00, 0x01, 0x09, 0x10};
/**
* @brief queue struct to contain the data
*/
typedef struct CATCH_QUEUE
{
    char *data;
    uint32_t len;
} CQ;
/**
 * @brief class decode h264
 */
class decoder_h264
{
public:
    char buf1[16000000];
    char buf1_shadow[16000000];
    int buf1_use_flag;
    char buf2[16000000];
    char buf3[16000000];
    int height;
    int width;
    /**
     * @brief catch the data stream in by users,
     *        queue size is always > 1, as it just 
     *        pops the front element when size is > 1
     */
    std::queue<CQ> cq_queue;
    /**
     * @brief catch the data which is readed into decoder
     *        if the size of this queue is bigger than 20,
     *        it will dequeue the front element and release
     *        ram
     */
    std::queue<CQ> cach_queue;
    /**
     * @brief just a counter
     */
    uint32_t frame_counter = 0;
    cv::Mat mat_cache;
    pthread_mutex_t clone_mutex;
    /* create decoder context. */
    context_t ctx;
    int ret = 0;
    /* save decode iterator number */
    int iterator_num = 0;
    decoder_h264();
    /**
     * @brief Construct a new decoder h264 object
     * 
     * @param height video height
     * @param width  video width
     */
    decoder_h264(int height, int width);
    ~decoder_h264();
    /**
     * @brief Get the mat object
     * 
     * @param mat_op the mat which cache the mat
     * @return int   0: success  other: fail
     */
    int get_mat(cv::Mat *mat_op);
    /**
     * @brief Set the defaults object, inner function
     * 
     * @param ctx 
     */
    void set_defaults(context_t *ctx);
    /**
     * @brief inner function
     * 
     * @return int 
     */
    int decode_proc(void);
    /**
     * @brief inner function 
     * 
     * @param ctx 
     * @param eos 
     * @param current_file 
     * @param current_loop 
     * @param nalu_parse_buffer 
     * @return true 
     * @return false 
     */
    bool decoder_proc_blocking(context_t &ctx, bool eos, uint32_t current_file,
                               int current_loop, char *nalu_parse_buffer);
    /**
     * @brief inner function
     */
    void abort(void);
    /**
     * @brief inner function
     * 
     * @param stream 
     * @param buffer 
     * @return int 
     */
    int read_decoder_input_chunk(ifstream *stream, NvBuffer *buffer);
    /**
     * @brief inner function
     */
    void query_and_set_capture(void);
    /**
     * @brief inner function
     * 
     * @param arg 
     * @return void* 
     */
    static void *dec_capture_loop_fcn(void *arg);
    /**
     * @brief memcpy data from pointer to the decoder's queue
     *        this function must be called periodly
     * @param data 
     * @param len 
     */
    void stream_in_data(uint8_t *data, uint32_t len);

    /**
    * @brief test thread
    * @param argv 
    * @return void* 
    */
    static void *image_save_thread(void *argv);
    pthread_t handle_image_save_thread;

    /**
    * @brief color transform thread for getting mat
    * @param argv 
    * @return void* 
    */
    static void *image_cvt(void *argv);
    pthread_t handle_image_cvt;
};

#endif //DECODE_TX2_DECODER_H264_H
